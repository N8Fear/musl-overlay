diff --git a/Makefile b/Makefile
index 3d0d472..f0fa346 100644
--- a/Makefile
+++ b/Makefile
@@ -1,42 +1,58 @@
 #
 # Linux Frame Buffer Device Configuration
 #
+srcdir = .
+
+CC = gcc
+CFLAGS = -Wall -O2
+BISON = bison -d
+FLEX = flex
+INSTALL = install
+INSTALL_PROGRAM = $(INSTALL) -m 755
+INSTALL_DATA = $(INSTALL) -m 644
+RM = rm -f
+
+all: fbset con2fbmap
+
+fbset: fbset.o modes.tab.o lex.yy.o
+
+fbset.o: fbset.c fbset.h fb.h
+modes.tab.o: modes.tab.c fbset.h fb.h
+lex.yy.o: lex.yy.c fbset.h modes.tab.h
+
+lex.yy.c: modes.l
+	$(FLEX) $<
+
+modes.tab.c modes.tab.h: modes.y
+	$(BISON) $<
+
+con2fbmap: con2fbmap.o
+con2fbmap.o: con2fbmap.c
+
+install: fbset con2fbmap
+	$(INSTALL) -d $(DESTDIR)/etc
+	$(INSTALL) -d $(DESTDIR)/bin
+	$(INSTALL) -d $(DESTDIR)/usr/share/man/man1
+	$(INSTALL) -d $(DESTDIR)/usr/share/man/man5
+	$(INSTALL_DATA) $(srcdir)/etc/fb.modes.ATI $(DESTDIR)/etc/fb.modes
+	$(INSTALL_DATA) $(srcdir)/fb.modes.5 $(DESTDIR)/usr/share/man/man5
+	$(INSTALL_PROGRAM) fbset $(DESTDIR)/bin
+	$(INSTALL_DATA) $(srcdir)/fbset.8 $(DESTDIR)/usr/share/man/man1/fbset.1
+	$(INSTALL_PROGRAM) $(srcdir)/modeline2fb $(DESTDIR)/bin
+	$(INSTALL_PROGRAM) con2fbmap $(DESTDIR)/bin
+	$(INSTALL_DATA) $(srcdir)/con2fbmap.1 $(DESTDIR)/usr/share/man/man1
+	$(INSTALL_DATA) $(srcdir)/modeline2fb.1 $(DESTDIR)/usr/share/man/man1
+
+install-devices:
+	if [ ! -c /dev/fb0 ]; then mknod $(DESTDIR)/dev/fb0 c 29 0; fi
+	if [ ! -c /dev/fb1 ]; then mknod $(DESTDIR)/dev/fb1 c 29 32; fi
+	if [ ! -c /dev/fb2 ]; then mknod $(DESTDIR)/dev/fb2 c 29 64; fi
+	if [ ! -c /dev/fb3 ]; then mknod $(DESTDIR)/dev/fb3 c 29 96; fi
+	if [ ! -c /dev/fb4 ]; then mknod $(DESTDIR)/dev/fb4 c 29 128; fi
+	if [ ! -c /dev/fb5 ]; then mknod $(DESTDIR)/dev/fb5 c 29 160; fi
+	if [ ! -c /dev/fb6 ]; then mknod $(DESTDIR)/dev/fb6 c 29 192; fi
+	if [ ! -c /dev/fb7 ]; then mknod $(DESTDIR)/dev/fb7 c 29 224; fi
+
+ clean:
+	$(RM) *.o fbset con2fbmap lex.yy.c modes.tab.c modes.tab.h
 
-BISON =		bison -d
-FLEX =		flex
-INSTALL =	install
-RM =		rm -f
-
-All:		fbset
-
-
-fbset:		fbset.o modes.tab.o lex.yy.o
-
-fbset.o:	fbset.c fbset.h fb.h
-modes.tab.o:	modes.tab.c fbset.h fb.h
-lex.yy.o:	lex.yy.c fbset.h modes.tab.h
-
-lex.yy.c:	modes.l
-		$(FLEX) modes.l
-
-modes.tab.h:    modes.tab.c
-
-modes.tab.c:	modes.y
-		$(BISON) modes.y
-
-install:	fbset
-		if [ -f /sbin/fbset ]; then rm /sbin/fbset; fi
-		$(INSTALL) fbset /usr/sbin
-		$(INSTALL) fbset.8 /usr/man/man8
-		$(INSTALL) fb.modes.5 /usr/man/man5
-		if [ ! -c /dev/fb0 ]; then mknod /dev/fb0 c 29 0; fi
-		if [ ! -c /dev/fb1 ]; then mknod /dev/fb1 c 29 32; fi
-		if [ ! -c /dev/fb2 ]; then mknod /dev/fb2 c 29 64; fi
-		if [ ! -c /dev/fb3 ]; then mknod /dev/fb3 c 29 96; fi
-		if [ ! -c /dev/fb4 ]; then mknod /dev/fb4 c 29 128; fi
-		if [ ! -c /dev/fb5 ]; then mknod /dev/fb5 c 29 160; fi
-		if [ ! -c /dev/fb6 ]; then mknod /dev/fb6 c 29 192; fi
-		if [ ! -c /dev/fb7 ]; then mknod /dev/fb7 c 29 224; fi
-
-clean:
-		$(RM) *.o fbset lex.yy.c modes.tab.c modes.tab.h
diff --git a/con2fbmap.1 b/con2fbmap.1
new file mode 100644
index 0000000..e0b9416
--- /dev/null
+++ b/con2fbmap.1
@@ -0,0 +1,29 @@
+.TH con2fbmap 1 2006-01-18 2.1 "Linux frame buffer utils"
+.SH NAME
+con2fbmap \- shows and sets mapping between consoles and framebuffer devices.
+.SH SYNOPSIS
+.B con2fbmap
+.RI console
+.RI [ framebuffer ]
+.SH DESCRIPTION
+.B This documentation is not finished
+.PP
+.B con2fbmap
+is a system utility to show or change the mapping of the consoles  to the
+frame buffer device. The frame buffer device provides a simple and unique
+interface to access different kinds of graphic displays.
+.PP
+Frame buffer devices are accessed via special device nodes located in the
+/dev directory. The naming scheme for these nodes is always
+.IR \fBfb < n >,
+where
+.I n
+is the number of the used frame buffer device.
+.PP
+.SH OPTIONS
+The first option must be there, and identify the console on which to work.
+If the second option is not set, con2fbmap shows the current mapping of
+identified console. If the second argument is given (as a number) con2fbmap
+maps the identified console to said framebuffer device.
+.TP
+Sven LUTHER <luther@debian.org>
diff --git a/con2fbmap.c b/con2fbmap.c
new file mode 100644
index 0000000..4d2c908
--- /dev/null
+++ b/con2fbmap.c
@@ -0,0 +1,66 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <linux/fb.h>
+
+#define DEFAULT_FRAMEBUFFER	"/dev/fb0"
+#define DEFAULT_FRAMEBUFFER_DEVFS	"/dev/fb/0"
+
+const char *programname;
+
+void Usage(void)
+{
+    fprintf(stderr, "\nUsage: %s console [framebuffer]\n\n", programname);
+    exit(1);
+}
+
+int main(int argc, char *argv[])
+{
+    int do_write = 0;
+    char *fbpath; /* any frame buffer will do */
+    int fd;
+    struct fb_con2fbmap map;
+
+    programname = argv[0];
+    switch (argc) {
+	case 3:
+	    do_write = 1;
+	    map.framebuffer = atoi(argv[2]);
+	case 2:
+	    map.console = atoi(argv[1]);
+	    break;
+	default:
+	    Usage();
+    }
+
+    if (access("/dev/.devfsd", F_OK) == 0)  /* devfs detected */
+	fbpath = DEFAULT_FRAMEBUFFER_DEVFS;
+    else
+	fbpath = DEFAULT_FRAMEBUFFER;
+
+    if ((fd = open(fbpath, O_RDONLY)) == -1) {
+	fprintf(stderr, "open %s: %s\n", fbpath, strerror(errno));
+	exit(1);
+    }
+    if (do_write) {
+	if (ioctl(fd, FBIOPUT_CON2FBMAP, &map)) {
+	    fprintf(stderr, "ioctl FBIOPUT_CON2FBMAP: %s\n", strerror(errno));
+	    exit(1);
+	}
+    } else {
+	if (ioctl(fd, FBIOGET_CON2FBMAP, &map)) {
+	    fprintf(stderr, "ioctl FBIOGET_CON2FBMAP: %s\n", strerror(errno));
+	    exit(1);
+	}
+	printf("console %d is mapped to framebuffer %d\n", map.console,
+	       map.framebuffer);
+    }
+    close(fd);
+    exit(0);
+}
diff --git a/etc/fb.modes.ATI b/etc/fb.modes.ATI
index d69a84b..e6a4fb7 100644
--- a/etc/fb.modes.ATI
+++ b/etc/fb.modes.ATI
@@ -6,6 +6,8 @@
 #       Mach64 Programmer's Guide, Appendix C
 #       (C) 1998 ATI Technologies Inc.
 #
+#  Kop: this are very generic modes and not only for ATI cards.
+#
 
 #
 #	640x480, 60 Hz, Non-Interlaced (25.175 MHz dotclock)
@@ -132,6 +134,36 @@ mode "640x480-100"
     timings 22272 48 32 17 22 128 12
 endmode
  
+
+#
+#       768x576, 75 Hz, Non-Interlaced (49.188 MHz dotclock)
+#
+#                               Horizontal      Vertical
+#       Resolution              768             576
+#       Scan Frequency          46.580 kHz      75.008 Hz
+#       Sync Width              us              ms
+#                               chars           lines
+#       Front Porch             us              ms
+#                               chars           lines
+#       Back Porch              us              ms
+#                               chars           lines
+#       Active Time             us              ms
+#                               chars           lines
+#       Blank Time              us              ms
+#                               chars           lines
+#       Polarity                negative        negative
+#
+# This is a mode often used, because fbtv suggests this, since
+# this is the mode for "normal" TVs.
+#
+
+mode "768x576-75"
+    # D: 49.188 MHz, H: 46.580 kHz, V: 75.008 Hz
+    geometry 768 576 768 576 32
+    timings 20330 128 32 32 8 128 5
+endmode
+
+
 #
 #	800x600, 48 Hz, Interlaced (36.00 MHz dotclock)
 #	
@@ -430,7 +462,7 @@ endmode
 #	1024x768, 72 Hz, Non-Interlaced (75.00 MHz dotclock)
 #	
 #				Horizontal	Vertical
-#	Resolution		10224		768
+#	Resolution		1024		768
 #	Scan Frequency		58.230 kHz	72.245 Hz
 #	Sync Width		1.813 us	0.103 ms
 #				17 chars	6 lines
@@ -447,7 +479,7 @@ endmode
 
 mode "1024x768-72"
     # D: 75.00 MHz, H: 58.230 kHz, V: 72.245 Hz
-    geometry 10224 768 10224 768 8
+    geometry 1024 768 1024 768 8
     timings 13334 104 24 29 3 136 6
 endmode
  
@@ -691,7 +723,45 @@ mode "1152x864-80"
     hsync high
     vsync high
 endmode
- 
+
+#
+#       1280x960, 75 Hz, Non-Interlaced (126.00 MHz dotclock)
+#
+#                               Horizontal      Vertical
+#       Resolution              1280            960
+#       Scan Frequency          74.788 kHz      74.788 Hz
+#       Sync Width              1.018 us        0.092 ms
+#                               14 chars        7 lines
+#       Front Porch             0.127 us        0.393 ms
+#                               2 chars         30 lines
+#       Back Porch              1.473 us        0.747 ms
+#                               20 chars        57 lines
+#       Active Time             10.473 us       11.311 ms
+#                               144 chars       864 lines
+#       Blank Time              2.618 us        1.231 ms
+#                               36 chars        94 lines
+#       Polarity                positive        positive
+#
+
+mode "1280x960-75-8"
+    # D: 125.644 MHz, H: 74.788 kHz, V: 74.788 Hz
+    geometry 1280 960 1280 960 8
+    timings 7959 224 32 36 1 144 3
+endmode
+
+mode "1280x960-75"
+    # D: 125.644 MHz, H: 74.788 kHz, V: 74.788 Hz
+    geometry 1280 960 1280 960 16
+    timings 7959 224 32 36 1 144 3
+endmode
+
+mode "1280x960-75-32"
+    # D: 125.644 MHz, H: 74.788 kHz, V: 74.788 Hz
+    geometry 1280 960 1280 960 32
+    timings 7959 224 32 36 1 144 3
+endmode
+
+
 #
 #	1280x1024, 43 Hz, Interlaced (80.00 MHz dotclock)
 #	
@@ -849,13 +919,13 @@ endmode
 #
 
 mode "1280x1024-75"
-    # D: 135.00 MHz, H: 79.976 kHz, V: 75.02 Hz
-    geometry 1280 1024 1280 1024 8
-    timings 7408 248 16 38 1 144 3
+    # D: 134.880 MHz, H: 79.905 kHz, V: 74.958 Hz
+    geometry 1280 1024 1280 3264 8
+    timings 7414 232 64 38 1 112 3
     hsync high
     vsync high
 endmode
- 
+
 #
 #	1600x1200, 60 Hz, Non-Interlaced (156.00 MHz dotclock)
 #	
diff --git a/fb.h b/fb.h
index b901d9e..6a82748 100644
--- a/fb.h
+++ b/fb.h
@@ -1,16 +1,15 @@
 #ifndef _LINUX_FB_H
 #define _LINUX_FB_H
 
-#include <asm/types.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#ifdef __KERNEL__
+#include <linux/kgdb.h>
+#endif /* __KERNEL__ */
 
 /* Definitions of frame buffers						*/
 
-#define FB_MAJOR	29
-
-#define FB_MODES_SHIFT		5	/* 32 modes per framebuffer */
-#define FB_NUM_MINORS		256	/* 256 Minors               */
-#define FB_MAX			(FB_NUM_MINORS / (1 << FB_MODES_SHIFT))
-#define GET_FB_IDX(node)	(MINOR(node) >> FB_MODES_SHIFT)
+#define FB_MAX			32	/* sufficient for now */
 
 /* ioctls
    0x46 is 'F'								*/
@@ -20,12 +19,26 @@
 #define FBIOGETCMAP		0x4604
 #define FBIOPUTCMAP		0x4605
 #define FBIOPAN_DISPLAY		0x4606
+#ifdef __KERNEL__
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor_user)
+#else
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+#endif
 /* 0x4607-0x460B are defined below */
 /* #define FBIOGET_MONITORSPEC	0x460C */
 /* #define FBIOPUT_MONITORSPEC	0x460D */
 /* #define FBIOSWITCH_MONIBIT	0x460E */
 #define FBIOGET_CON2FBMAP	0x460F
 #define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, __u32)
 
 #define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
 #define FB_TYPE_PLANES			1	/* Non interleaved planes */
@@ -38,6 +51,13 @@
 #define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
 #define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
 #define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
 
 #define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
 #define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
@@ -73,14 +93,70 @@
 #define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
 #define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
 #define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
-#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			 */
-#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			 */
-#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			 */
-#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/
 
 struct fb_fix_screeninfo {
 	char id[16];			/* identification string eg "TT Builtin" */
-	char *smem_start;		/* Start of frame buffer mem */
+	unsigned long smem_start;	/* Start of frame buffer mem */
 					/* (physical address) */
 	__u32 smem_len;			/* Length of frame buffer mem */
 	__u32 type;			/* see FB_TYPE_*		*/
@@ -90,18 +166,23 @@ struct fb_fix_screeninfo {
 	__u16 ypanstep;			/* zero if no hardware panning  */
 	__u16 ywrapstep;		/* zero if no hardware ywrap    */
 	__u32 line_length;		/* length of a line in bytes    */
-	char *mmio_start;		/* Start of Memory Mapped I/O   */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
 					/* (physical address) */
 	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
-	__u32 accel;			/* Type of acceleration available */
+	__u32 accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
 	__u16 reserved[3];		/* Reserved for future compatibility */
 };
 
 /* Interpretation of offset for color fields: All offsets are from the right,
  * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
  * can use the offset as right argument to <<). A pixel afterwards is a bit
- * stream and is written to video memory as that unmodified. This implies
- * big-endian byte order if bits_per_pixel is greater than 8.
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the pallette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
  */
 struct fb_bitfield {
 	__u32 offset;			/* beginning of bitfield	*/
@@ -111,6 +192,7 @@ struct fb_bitfield {
 };
 
 #define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
 
 #define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
 #define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
@@ -120,8 +202,10 @@ struct fb_bitfield {
 #define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
 #define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
 #define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
 
-#define FB_ACCELF_TEXT		1	/* text mode acceleration */
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
 
 #define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
 #define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
@@ -135,12 +219,24 @@ struct fb_bitfield {
 #define FB_VMODE_NONINTERLACED  0	/* non interlaced */
 #define FB_VMODE_INTERLACED	1	/* interlaced	*/
 #define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
 #define FB_VMODE_MASK		255
 
 #define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
 #define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
 #define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
 
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
 struct fb_var_screeninfo {
 	__u32 xres;			/* visible resolution		*/
 	__u32 yres;
@@ -164,7 +260,7 @@ struct fb_var_screeninfo {
 	__u32 height;			/* height of picture in mm    */
 	__u32 width;			/* width of picture in mm     */
 
-	__u32 accel_flags;		/* acceleration flags (hints)	*/
+	__u32 accel_flags;		/* (OBSOLETE) see fb_info.flags */
 
 	/* Timing: All values in pixclocks, except pixclock (of course) */
 	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
@@ -176,7 +272,8 @@ struct fb_var_screeninfo {
 	__u32 vsync_len;		/* length of vertical sync	*/
 	__u32 sync;			/* see FB_SYNC_*		*/
 	__u32 vmode;			/* see FB_VMODE_*		*/
-	__u32 reserved[6];		/* Reserved for future compatibility */
+	__u32 rotate;			/* angle we rotate counter clockwise */
+	__u32 reserved[5];		/* Reserved for future compatibility */
 };
 
 struct fb_cmap {
@@ -193,305 +290,885 @@ struct fb_con2fbmap {
 	__u32 framebuffer;
 };
 
-struct fb_monspecs {
-	__u32 hfmin;			/* hfreq lower limit (Hz) */
-	__u32 hfmax; 			/* hfreq upper limit (Hz) */
-	__u16 vfmin;			/* vfreq lower limit (Hz) */
-	__u16 vfmax;			/* vfreq upper limit (Hz) */
-	unsigned dpms : 1;		/* supports DPMS */
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	__u32 flags;			/* FB_VBLANK flags */
+	__u32 count;			/* counter of retraces since boot */
+	__u32 vcount;			/* current scanline position */
+	__u32 hcount;			/* current scandot position */
+	__u32 reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	__u32 dx;
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 sx;
+	__u32 sy;
+};
+
+struct fb_fillrect {
+	__u32 dx;	/* screen-relative */
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 color;
+	__u32 rop;
+};
+
+struct fb_image {
+	__u32 dx;		/* Where to place image */
+	__u32 dy;
+	__u32 width;		/* Size of image */
+	__u32 height;
+	__u32 fg_color;		/* Only used when a mono bitmap */
+	__u32 bg_color;
+	__u8  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
 };
 
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	__u16 x, y;
+};
+
+struct fb_cursor {
+	__u16 set;		/* what to set */
+	__u16 enable;		/* cursor on/off */
+	__u16 rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+#ifdef CONFIG_FB_BACKLIGHT
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+#endif
+
 #ifdef __KERNEL__
 
 #include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/notifier.h>
+#include <linux/list.h>
+#include <linux/backlight.h>
+#include <linux/slab.h>
+#include <asm/io.h>
 
-
-struct fb_info;
-struct fb_info_gen;
 struct vm_area_struct;
+struct fb_info;
+struct device;
 struct file;
 
-    /*
-     *  Frame buffer operations
-     */
+/* Definitions below are used in the parsed monitor specs */
+#define FB_DPMS_ACTIVE_OFF	1
+#define FB_DPMS_SUSPEND		2
+#define FB_DPMS_STANDBY		4
+
+#define FB_DISP_DDI		1
+#define FB_DISP_ANA_700_300	2
+#define FB_DISP_ANA_714_286	4
+#define FB_DISP_ANA_1000_400	8
+#define FB_DISP_ANA_700_000	16
+
+#define FB_DISP_MONO		32
+#define FB_DISP_RGB		64
+#define FB_DISP_MULTI		128
+#define FB_DISP_UNKNOWN		256
+
+#define FB_SIGNAL_NONE		0
+#define FB_SIGNAL_BLANK_BLANK	1
+#define FB_SIGNAL_SEPARATE	2
+#define FB_SIGNAL_COMPOSITE	4
+#define FB_SIGNAL_SYNC_ON_GREEN	8
+#define FB_SIGNAL_SERRATION_ON	16
+
+#define FB_MISC_PRIM_COLOR	1
+#define FB_MISC_1ST_DETAIL	2	/* First Detailed Timing is preferred */
+struct fb_chroma {
+	__u32 redx;	/* in fraction of 1024 */
+	__u32 greenx;
+	__u32 bluex;
+	__u32 whitex;
+	__u32 redy;
+	__u32 greeny;
+	__u32 bluey;
+	__u32 whitey;
+};
 
-struct fb_ops {
-    /* open/release and usage marking */
-    int (*fb_open)(struct fb_info *info, int user);
-    int (*fb_release)(struct fb_info *info, int user);
-    /* get non settable parameters */
-    int (*fb_get_fix)(struct fb_fix_screeninfo *fix, int con,
-		      struct fb_info *info); 
-    /* get settable parameters */
-    int (*fb_get_var)(struct fb_var_screeninfo *var, int con,
-		      struct fb_info *info);		
-    /* set settable parameters */
-    int (*fb_set_var)(struct fb_var_screeninfo *var, int con,
-		      struct fb_info *info);		
-    /* get colormap */
-    int (*fb_get_cmap)(struct fb_cmap *cmap, int kspc, int con,
-		       struct fb_info *info);
-    /* set colormap */
-    int (*fb_set_cmap)(struct fb_cmap *cmap, int kspc, int con,
-		       struct fb_info *info);
-    /* pan display */
-    int (*fb_pan_display)(struct fb_var_screeninfo *var, int con,
-			  struct fb_info *info);
-    /* perform fb specific ioctl */
-    int (*fb_ioctl)(struct inode *inode, struct file *file, unsigned int cmd,
-		    unsigned long arg, int con, struct fb_info *info);
-    /* perform fb specific mmap */
-    int (*fb_mmap)(struct fb_info *info, struct file *file, struct vm_area_struct *vma);
-    /* switch to/from raster image mode */
-    int (*fb_rasterimg)(struct fb_info *info, int start);
+struct fb_monspecs {
+	struct fb_chroma chroma;
+	struct fb_videomode *modedb;	/* mode database */
+	__u8  manufacturer[4];		/* Manufacturer */
+	__u8  monitor[14];		/* Monitor String */
+	__u8  serial_no[14];		/* Serial Number */
+	__u8  ascii[14];		/* ? */
+	__u32 modedb_len;		/* mode database length */
+	__u32 model;			/* Monitor Model */
+	__u32 serial;			/* Serial Number - Integer */
+	__u32 year;			/* Year manufactured */
+	__u32 week;			/* Week Manufactured */
+	__u32 hfmin;			/* hfreq lower limit (Hz) */
+	__u32 hfmax;			/* hfreq upper limit (Hz) */
+	__u32 dclkmin;			/* pixelclock lower limit (Hz) */
+	__u32 dclkmax;			/* pixelclock upper limit (Hz) */
+	__u16 input;			/* display type - see FB_DISP_* */
+	__u16 dpms;			/* DPMS support - see FB_DPMS_ */
+	__u16 signal;			/* Signal Type - see FB_SIGNAL_* */
+	__u16 vfmin;			/* vfreq lower limit (Hz) */
+	__u16 vfmax;			/* vfreq upper limit (Hz) */
+	__u16 gamma;			/* Gamma - in fractions of 100 */
+	__u16 gtf	: 1;		/* supports GTF */
+	__u16 misc;			/* Misc flags - see FB_MISC_* */
+	__u8  version;			/* EDID version... */
+	__u8  revision;			/* ...and revision */
+	__u8  max_x;			/* Maximum horizontal size (cm) */
+	__u8  max_y;			/* Maximum vertical size (cm) */
 };
 
+struct fb_cmap_user {
+	__u32 start;			/* First entry	*/
+	__u32 len;			/* Number of entries */
+	__u16 __user *red;		/* Red values	*/
+	__u16 __user *green;
+	__u16 __user *blue;
+	__u16 __user *transp;		/* transparency, can be NULL */
+};
 
-   /*
-    *    This is the interface between the low-level console driver and the
-    *    low-level frame buffer device
-    */
-
-struct display {
-    /* Filled in by the frame buffer device */
-
-    struct fb_var_screeninfo var;   /* variable infos. yoffset and vmode */
-				    /* are updated by fbcon.c */
-    struct fb_cmap cmap;            /* colormap */
-    char *screen_base;              /* pointer to top of virtual screen */    
-				    /* (virtual address) */
-    int visual;
-    int type;                       /* see FB_TYPE_* */
-    int type_aux;                   /* Interleave for interleaved Planes */
-    u_short ypanstep;               /* zero if no hardware ypan */
-    u_short ywrapstep;              /* zero if no hardware ywrap */
-    u_long line_length;             /* length of a line in bytes */
-    u_short can_soft_blank;         /* zero if no hardware blanking */
-    u_short inverse;                /* != 0 text black on white as default */
-    struct display_switch *dispsw;  /* low level operations */
-    void *dispsw_data;		    /* optional dispsw helper data */
-
-#if 0
-    struct fb_fix_cursorinfo fcrsr;
-    struct fb_var_cursorinfo *vcrsr;
-    struct fb_cursorstate crsrstate;
-#endif
+struct fb_image_user {
+	__u32 dx;			/* Where to place image */
+	__u32 dy;
+	__u32 width;			/* Size of image */
+	__u32 height;
+	__u32 fg_color;			/* Only used when a mono bitmap */
+	__u32 bg_color;
+	__u8  depth;			/* Depth of the image */
+	const char __user *data;	/* Pointer to image data */
+	struct fb_cmap_user cmap;	/* color map info */
+};
 
-    /* Filled in by the low-level console driver */
-
-    struct vc_data *conp;           /* pointer to console data */
-    struct fb_info *fb_info;        /* frame buffer for this console */
-    int vrows;                      /* number of virtual rows */
-    unsigned short cursor_x;	    /* current cursor position */
-    unsigned short cursor_y;
-    int fgcol;                      /* text colors */
-    int bgcol;
-    u_long next_line;               /* offset to one line below */
-    u_long next_plane;              /* offset to next plane */
-    u_char *fontdata;               /* Font associated to this display */
-    unsigned short _fontheightlog;
-    unsigned short _fontwidthlog;
-    unsigned short _fontheight;
-    unsigned short _fontwidth;
-    int userfont;                   /* != 0 if fontdata kmalloc()ed */
-    u_short scrollmode;             /* Scroll Method */
-    short yscroll;                  /* Hardware scrolling */
-    unsigned char fgshift, bgshift;
-    unsigned short charmask;	    /* 0xff or 0x1ff */
+struct fb_cursor_user {
+	__u16 set;			/* what to set */
+	__u16 enable;			/* cursor on/off */
+	__u16 rop;			/* bitop operation */
+	const char __user *mask;	/* cursor mask bits */
+	struct fbcurpos hot;		/* cursor hot spot */
+	struct fb_image_user image;	/* Cursor image */
 };
 
+/*
+ * Register/unregister for framebuffer events
+ */
 
-struct fb_info {
-   char modename[40];			/* default video mode */
-   kdev_t node;
-   int flags;
-#define FBINFO_FLAG_MODULE	1	/* Low-level driver is a module */
-   struct fb_ops *fbops;
-   struct fb_monspecs monspecs;
-   struct display *disp;		/* initial display variable */
-   struct vc_data *display_fg;		/* Console visible on this display */
-   char fontname[40];			/* default font name */
-   int (*changevar)(int);		/* tell console var has changed */
-   int (*switch_con)(int, struct fb_info*);
-					/* tell fb to switch consoles */
-   int (*updatevar)(int, struct fb_info*);
-					/* tell fb to update the vars */
-   void (*blank)(int, struct fb_info*);	/* tell fb to (un)blank the screen */
-					/* arg = 0: unblank */
-					/* arg > 0: VESA level (arg-1) */
-
-   /* From here on everything is device dependent */
+/*	The resolution of the passed in fb_info about to change */ 
+#define FB_EVENT_MODE_CHANGE		0x01
+/*	The display on this fb_info is beeing suspended, no access to the
+ *	framebuffer is allowed any more after that call returns
+ */
+#define FB_EVENT_SUSPEND		0x02
+/*	The display on this fb_info was resumed, you can restore the display
+ *	if you own it
+ */
+#define FB_EVENT_RESUME			0x03
+/*      An entry from the modelist was removed */
+#define FB_EVENT_MODE_DELETE            0x04
+/*      A driver registered itself */
+#define FB_EVENT_FB_REGISTERED          0x05
+/*      A driver unregistered itself */
+#define FB_EVENT_FB_UNREGISTERED        0x06
+/*      CONSOLE-SPECIFIC: get console to framebuffer mapping */
+#define FB_EVENT_GET_CONSOLE_MAP        0x07
+/*      CONSOLE-SPECIFIC: set console to framebuffer mapping */
+#define FB_EVENT_SET_CONSOLE_MAP        0x08
+/*      A hardware display blank change occurred */
+#define FB_EVENT_BLANK                  0x09
+/*      Private modelist is to be replaced */
+#define FB_EVENT_NEW_MODELIST           0x0A
+/*	The resolution of the passed in fb_info about to change and
+        all vc's should be changed         */
+#define FB_EVENT_MODE_CHANGE_ALL	0x0B
+/*	A software display blank change occurred */
+#define FB_EVENT_CONBLANK               0x0C
+/*      Get drawing requirements        */
+#define FB_EVENT_GET_REQ                0x0D
+/*      Unbind from the console if possible */
+#define FB_EVENT_FB_UNBIND              0x0E
+/*      CONSOLE-SPECIFIC: remap all consoles to new fb - for vga switcheroo */
+#define FB_EVENT_REMAP_ALL_CONSOLE      0x0F
+
+struct fb_event {
+	struct fb_info *info;
+	void *data;
 };
 
-#ifdef MODULE
-#define FBINFO_FLAG_DEFAULT	FBINFO_FLAG_MODULE
-#else
-#define FBINFO_FLAG_DEFAULT	0
-#endif
+struct fb_blit_caps {
+	u32 x;
+	u32 y;
+	u32 len;
+	u32 flags;
+};
 
-    /*
-     *  This structure abstracts from the underlying hardware. It is not
-     *  mandatory but used by the `generic' frame buffer operations.
-     *  Read drivers/video/skeletonfb.c for more information.
-     */
+extern int fb_register_client(struct notifier_block *nb);
+extern int fb_unregister_client(struct notifier_block *nb);
+extern int fb_notifier_call_chain(unsigned long val, void *v);
+/*
+ * Pixmap structure definition
+ *
+ * The purpose of this structure is to translate data
+ * from the hardware independent format of fbdev to what
+ * format the hardware needs.
+ */
+
+#define FB_PIXMAP_DEFAULT 1     /* used internally by fbcon */
+#define FB_PIXMAP_SYSTEM  2     /* memory is in system RAM  */
+#define FB_PIXMAP_IO      4     /* memory is iomapped       */
+#define FB_PIXMAP_SYNC    256   /* set if GPU can DMA       */
+
+struct fb_pixmap {
+	u8  *addr;		/* pointer to memory			*/
+	u32 size;		/* size of buffer in bytes		*/
+	u32 offset;		/* current offset to buffer		*/
+	u32 buf_align;		/* byte alignment of each bitmap	*/
+	u32 scan_align;		/* alignment per scanline		*/
+	u32 access_align;	/* alignment per read/write (bits)	*/
+	u32 flags;		/* see FB_PIXMAP_*			*/
+	u32 blit_x;             /* supported bit block dimensions (1-32)*/
+	u32 blit_y;             /* Format: blit_x = 1 << (width - 1)    */
+	                        /*         blit_y = 1 << (height - 1)   */
+	                        /* if 0, will be set to 0xffffffff (all)*/
+	/* access methods */
+	void (*writeio)(struct fb_info *info, void __iomem *dst, void *src, unsigned int size);
+	void (*readio) (struct fb_info *info, void *dst, void __iomem *src, unsigned int size);
+};
 
-struct fbgen_hwswitch {
-    void (*detect)(void);
-    int (*encode_fix)(struct fb_fix_screeninfo *fix, const void *par,
-		      struct fb_info_gen *info);
-    int (*decode_var)(const struct fb_var_screeninfo *var, void *par,
-		      struct fb_info_gen *info);
-    int (*encode_var)(struct fb_var_screeninfo *var, const void *par,
-		      struct fb_info_gen *info);
-    void (*get_par)(void *par, struct fb_info_gen *info);
-    void (*set_par)(const void *par, struct fb_info_gen *info);
-    int (*getcolreg)(unsigned regno, unsigned *red, unsigned *green,
-		     unsigned *blue, unsigned *transp, struct fb_info *info);
-    int (*setcolreg)(unsigned regno, unsigned red, unsigned green,
-		     unsigned blue, unsigned transp, struct fb_info *info);
-    int (*pan_display)(const struct fb_var_screeninfo *var,
-		       struct fb_info_gen *info);
-    int (*blank)(int blank_mode, struct fb_info_gen *info);
-    void (*set_disp)(const void *par, struct display *disp,
-		     struct fb_info_gen *info);
+#ifdef CONFIG_FB_DEFERRED_IO
+struct fb_deferred_io {
+	/* delay between mkwrite and deferred handler */
+	unsigned long delay;
+	struct mutex lock; /* mutex that protects the page list */
+	struct list_head pagelist; /* list of touched pages */
+	/* callback */
+	void (*deferred_io)(struct fb_info *info, struct list_head *pagelist);
 };
+#endif
+
+/*
+ * Frame buffer operations
+ *
+ * LOCKING NOTE: those functions must _ALL_ be called with the console
+ * semaphore held, this is the only suitable locking mechanism we have
+ * in 2.6. Some may be called at interrupt time at this point though.
+ *
+ * The exception to this is the debug related hooks.  Putting the fb
+ * into a debug state (e.g. flipping to the kernel console) and restoring
+ * it must be done in a lock-free manner, so low level drivers should
+ * keep track of the initial console (if applicable) and may need to
+ * perform direct, unlocked hardware writes in these hooks.
+ */
+
+struct fb_ops {
+	/* open/release and usage marking */
+	struct module *owner;
+	int (*fb_open)(struct fb_info *info, int user);
+	int (*fb_release)(struct fb_info *info, int user);
+
+	/* For framebuffers with strange non linear layouts or that do not
+	 * work with normal memory mapped access
+	 */
+	ssize_t (*fb_read)(struct fb_info *info, char __user *buf,
+			   size_t count, loff_t *ppos);
+	ssize_t (*fb_write)(struct fb_info *info, const char __user *buf,
+			    size_t count, loff_t *ppos);
+
+	/* checks var and eventually tweaks it to something supported,
+	 * DO NOT MODIFY PAR */
+	int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);
+
+	/* set the video mode according to info->var */
+	int (*fb_set_par)(struct fb_info *info);
+
+	/* set color register */
+	int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green,
+			    unsigned blue, unsigned transp, struct fb_info *info);
+
+	/* set color registers in batch */
+	int (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info);
+
+	/* blank display */
+	int (*fb_blank)(int blank, struct fb_info *info);
+
+	/* pan display */
+	int (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info);
+
+	/* Draws a rectangle */
+	void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect);
+	/* Copy data from area to another */
+	void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region);
+	/* Draws a image to the display */
+	void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);
 
-struct fb_info_gen {
-    struct fb_info info;
+	/* Draws cursor */
+	int (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor);
 
-    /* Entries for a generic frame buffer device */
-    /* Yes, this starts looking like C++ */
-    u_int parsize;
-    struct fbgen_hwswitch *fbhw;
+	/* Rotates the display */
+	void (*fb_rotate)(struct fb_info *info, int angle);
 
-   /* From here on everything is device dependent */
+	/* wait for blit idle, optional */
+	int (*fb_sync)(struct fb_info *info);
+
+	/* perform fb specific ioctl (optional) */
+	int (*fb_ioctl)(struct fb_info *info, unsigned int cmd,
+			unsigned long arg);
+
+	/* Handle 32bit compat ioctl (optional) */
+	int (*fb_compat_ioctl)(struct fb_info *info, unsigned cmd,
+			unsigned long arg);
+
+	/* perform fb specific mmap */
+	int (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma);
+
+	/* get capability given var */
+	void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,
+			    struct fb_var_screeninfo *var);
+
+	/* teardown any resources to do with this framebuffer */
+	void (*fb_destroy)(struct fb_info *info);
+
+	/* called at KDB enter and leave time to prepare the console */
+	int (*fb_debug_enter)(struct fb_info *info);
+	int (*fb_debug_leave)(struct fb_info *info);
 };
 
-    /*
-     *  `Generic' versions of the frame buffer device operations
-     */
+#ifdef CONFIG_FB_TILEBLITTING
+#define FB_TILE_CURSOR_NONE        0
+#define FB_TILE_CURSOR_UNDERLINE   1
+#define FB_TILE_CURSOR_LOWER_THIRD 2
+#define FB_TILE_CURSOR_LOWER_HALF  3
+#define FB_TILE_CURSOR_TWO_THIRDS  4
+#define FB_TILE_CURSOR_BLOCK       5
+
+struct fb_tilemap {
+	__u32 width;                /* width of each tile in pixels */
+	__u32 height;               /* height of each tile in scanlines */
+	__u32 depth;                /* color depth of each tile */
+	__u32 length;               /* number of tiles in the map */
+	const __u8 *data;           /* actual tile map: a bitmap array, packed
+				       to the nearest byte */
+};
 
-extern int fbgen_get_fix(struct fb_fix_screeninfo *fix, int con,
-			 struct fb_info *info);
-extern int fbgen_get_var(struct fb_var_screeninfo *var, int con,
-			 struct fb_info *info);
-extern int fbgen_set_var(struct fb_var_screeninfo *var, int con,
-			 struct fb_info *info);
-extern int fbgen_get_cmap(struct fb_cmap *cmap, int kspc, int con,
-			  struct fb_info *info);
-extern int fbgen_set_cmap(struct fb_cmap *cmap, int kspc, int con,
-			  struct fb_info *info);
-extern int fbgen_pan_display(struct fb_var_screeninfo *var, int con,
-			     struct fb_info *info);
-extern int fbgen_ioctl(struct inode *inode, struct file *file,
-		       unsigned int cmd, unsigned long arg, int con,
-		       struct fb_info *info);
+struct fb_tilerect {
+	__u32 sx;                   /* origin in the x-axis */
+	__u32 sy;                   /* origin in the y-axis */
+	__u32 width;                /* number of tiles in the x-axis */
+	__u32 height;               /* number of tiles in the y-axis */
+	__u32 index;                /* what tile to use: index to tile map */
+	__u32 fg;                   /* foreground color */
+	__u32 bg;                   /* background color */
+	__u32 rop;                  /* raster operation */
+};
 
-    /*
-     *  Helper functions
-     */
+struct fb_tilearea {
+	__u32 sx;                   /* source origin in the x-axis */
+	__u32 sy;                   /* source origin in the y-axis */
+	__u32 dx;                   /* destination origin in the x-axis */
+	__u32 dy;                   /* destination origin in the y-axis */
+	__u32 width;                /* number of tiles in the x-axis */
+	__u32 height;               /* number of tiles in the y-axis */
+};
 
-extern int fbgen_do_set_var(struct fb_var_screeninfo *var, int isactive,
-			    struct fb_info_gen *info);
-extern void fbgen_set_disp(int con, struct fb_info_gen *info);
-extern void fbgen_install_cmap(int con, struct fb_info_gen *info);
-extern int fbgen_update_var(int con, struct fb_info *info);
-extern int fbgen_switch(int con, struct fb_info *info);
-extern void fbgen_blank(int blank, struct fb_info *info);
+struct fb_tileblit {
+	__u32 sx;                   /* origin in the x-axis */
+	__u32 sy;                   /* origin in the y-axis */
+	__u32 width;                /* number of tiles in the x-axis */
+	__u32 height;               /* number of tiles in the y-axis */
+	__u32 fg;                   /* foreground color */
+	__u32 bg;                   /* background color */
+	__u32 length;               /* number of tiles to draw */
+	__u32 *indices;             /* array of indices to tile map */
+};
 
+struct fb_tilecursor {
+	__u32 sx;                   /* cursor position in the x-axis */
+	__u32 sy;                   /* cursor position in the y-axis */
+	__u32 mode;                 /* 0 = erase, 1 = draw */
+	__u32 shape;                /* see FB_TILE_CURSOR_* */
+	__u32 fg;                   /* foreground color */
+	__u32 bg;                   /* background color */
+};
 
-struct fb_videomode {
-    const char *name;
-    struct fb_var_screeninfo var;
+struct fb_tile_ops {
+	/* set tile characteristics */
+	void (*fb_settile)(struct fb_info *info, struct fb_tilemap *map);
+
+	/* all dimensions from hereon are in terms of tiles */
+
+	/* move a rectangular region of tiles from one area to another*/
+	void (*fb_tilecopy)(struct fb_info *info, struct fb_tilearea *area);
+	/* fill a rectangular region with a tile */
+	void (*fb_tilefill)(struct fb_info *info, struct fb_tilerect *rect);
+	/* copy an array of tiles */
+	void (*fb_tileblit)(struct fb_info *info, struct fb_tileblit *blit);
+	/* cursor */
+	void (*fb_tilecursor)(struct fb_info *info,
+			      struct fb_tilecursor *cursor);
+	/* get maximum length of the tile map */
+	int (*fb_get_tilemax)(struct fb_info *info);
 };
+#endif /* CONFIG_FB_TILEBLITTING */
+
+/* FBINFO_* = fb_info.flags bit flags */
+#define FBINFO_MODULE		0x0001	/* Low-level driver is a module */
+#define FBINFO_HWACCEL_DISABLED	0x0002
+	/* When FBINFO_HWACCEL_DISABLED is set:
+	 *  Hardware acceleration is turned off.  Software implementations
+	 *  of required functions (copyarea(), fillrect(), and imageblit())
+	 *  takes over; acceleration engine should be in a quiescent state */
+
+/* hints */
+#define FBINFO_VIRTFB		0x0004 /* FB is System RAM, not device. */
+#define FBINFO_PARTIAL_PAN_OK	0x0040 /* otw use pan only for double-buffering */
+#define FBINFO_READS_FAST	0x0080 /* soft-copy faster than rendering */
+
+/* hardware supported ops */
+/*  semantics: when a bit is set, it indicates that the operation is
+ *   accelerated by hardware.
+ *  required functions will still work even if the bit is not set.
+ *  optional functions may not even exist if the flag bit is not set.
+ */
+#define FBINFO_HWACCEL_NONE		0x0000
+#define FBINFO_HWACCEL_COPYAREA		0x0100 /* required */
+#define FBINFO_HWACCEL_FILLRECT		0x0200 /* required */
+#define FBINFO_HWACCEL_IMAGEBLIT	0x0400 /* required */
+#define FBINFO_HWACCEL_ROTATE		0x0800 /* optional */
+#define FBINFO_HWACCEL_XPAN		0x1000 /* optional */
+#define FBINFO_HWACCEL_YPAN		0x2000 /* optional */
+#define FBINFO_HWACCEL_YWRAP		0x4000 /* optional */
+
+#define FBINFO_MISC_USEREVENT          0x10000 /* event request
+						  from userspace */
+#define FBINFO_MISC_TILEBLITTING       0x20000 /* use tile blitting */
+
+/* A driver may set this flag to indicate that it does want a set_par to be
+ * called every time when fbcon_switch is executed. The advantage is that with
+ * this flag set you can really be sure that set_par is always called before
+ * any of the functions dependent on the correct hardware state or altering
+ * that state, even if you are using some broken X releases. The disadvantage
+ * is that it introduces unwanted delays to every console switch if set_par
+ * is slow. It is a good idea to try this flag in the drivers initialization
+ * code whenever there is a bug report related to switching between X and the
+ * framebuffer console.
+ */
+#define FBINFO_MISC_ALWAYS_SETPAR   0x40000
 
+/* where the fb is a firmware driver, and can be replaced with a proper one */
+#define FBINFO_MISC_FIRMWARE        0x80000
+/*
+ * Host and GPU endianness differ.
+ */
+#define FBINFO_FOREIGN_ENDIAN	0x100000
+/*
+ * Big endian math. This is the same flags as above, but with different
+ * meaning, it is set by the fb subsystem depending FOREIGN_ENDIAN flag
+ * and host endianness. Drivers should not use this flag.
+ */
+#define FBINFO_BE_MATH  0x100000
 
-/* drivers/char/fbmem.c */
-extern int register_framebuffer(struct fb_info *fb_info);
-extern int unregister_framebuffer(const struct fb_info *fb_info);
-extern int fbmon_valid_timings(u_int pixclock, u_int htotal, u_int vtotal,
-			       const struct fb_info *fb_info);
-extern int fbmon_dpms(const struct fb_info *fb_info);
+/* report to the VT layer that this fb driver can accept forced console
+   output like oopses */
+#define FBINFO_CAN_FORCE_OUTPUT     0x200000
+
+struct fb_info {
+	atomic_t count;
+	int node;
+	int flags;
+	struct mutex lock;		/* Lock for open/release/ioctl funcs */
+	struct mutex mm_lock;		/* Lock for fb_mmap and smem_* fields */
+	struct fb_var_screeninfo var;	/* Current var */
+	struct fb_fix_screeninfo fix;	/* Current fix */
+	struct fb_monspecs monspecs;	/* Current Monitor specs */
+	struct work_struct queue;	/* Framebuffer event queue */
+	struct fb_pixmap pixmap;	/* Image hardware mapper */
+	struct fb_pixmap sprite;	/* Cursor hardware mapper */
+	struct fb_cmap cmap;		/* Current cmap */
+	struct list_head modelist;      /* mode list */
+	struct fb_videomode *mode;	/* current mode */
+
+#ifdef CONFIG_FB_BACKLIGHT
+	/* assigned backlight device */
+	/* set before framebuffer registration, 
+	   remove after unregister */
+	struct backlight_device *bl_dev;
+
+	/* Backlight level curve */
+	struct mutex bl_curve_mutex;	
+	u8 bl_curve[FB_BACKLIGHT_LEVELS];
+#endif
+#ifdef CONFIG_FB_DEFERRED_IO
+	struct delayed_work deferred_work;
+	struct fb_deferred_io *fbdefio;
+#endif
 
+	struct fb_ops *fbops;
+	struct device *device;		/* This is the parent */
+	struct device *dev;		/* This is this fb device */
+	int class_flag;                    /* private sysfs flags */
+#ifdef CONFIG_FB_TILEBLITTING
+	struct fb_tile_ops *tileops;    /* Tile Blitting */
+#endif
+	char __iomem *screen_base;	/* Virtual address */
+	unsigned long screen_size;	/* Amount of ioremapped VRAM or 0 */ 
+	void *pseudo_palette;		/* Fake palette of 16 colors */ 
+#define FBINFO_STATE_RUNNING	0
+#define FBINFO_STATE_SUSPENDED	1
+	u32 state;			/* Hardware state i.e suspend */
+	void *fbcon_par;                /* fbcon use-only private area */
+	/* From here on everything is device dependent */
+	void *par;
+	/* we need the PCI or similar aperture base/size not
+	   smem_start/size as smem_start may just be an object
+	   allocated inside the aperture so may not actually overlap */
+	struct apertures_struct {
+		unsigned int count;
+		struct aperture {
+			resource_size_t base;
+			resource_size_t size;
+		} ranges[0];
+	} *apertures;
+};
 
-extern int num_registered_fb;
-extern struct fb_info *registered_fb[FB_MAX];
-extern char con2fb_map[MAX_NR_CONSOLES];
+static inline struct apertures_struct *alloc_apertures(unsigned int max_num) {
+	struct apertures_struct *a = kzalloc(sizeof(struct apertures_struct)
+			+ max_num * sizeof(struct aperture), GFP_KERNEL);
+	if (!a)
+		return NULL;
+	a->count = max_num;
+	return a;
+}
 
-/* drivers/video/fbcon.c */
-extern struct display fb_display[MAX_NR_CONSOLES];
+#ifdef MODULE
+#define FBINFO_DEFAULT	FBINFO_MODULE
+#else
+#define FBINFO_DEFAULT	0
+#endif
 
-/* drivers/video/fbcmap.c */
-extern int fb_alloc_cmap(struct fb_cmap *cmap, int len, int transp);
-extern void fb_copy_cmap(struct fb_cmap *from, struct fb_cmap *to,
-			 int fsfromto);
-extern int fb_get_cmap(struct fb_cmap *cmap, int kspc,
-		       int (*getcolreg)(u_int, u_int *, u_int *, u_int *,
-					u_int *, struct fb_info *),
-		       struct fb_info *fb_info);
-extern int fb_set_cmap(struct fb_cmap *cmap, int kspc,
-		       int (*setcolreg)(u_int, u_int, u_int, u_int, u_int,
-					struct fb_info *),
-		       struct fb_info *fb_info);
-extern struct fb_cmap *fb_default_cmap(int len);
-extern void fb_invert_cmaps(void);
+// This will go away
+#define FBINFO_FLAG_MODULE	FBINFO_MODULE
+#define FBINFO_FLAG_DEFAULT	FBINFO_DEFAULT
 
-/* VESA Blanking Levels */
-#define VESA_NO_BLANKING	0
-#define VESA_VSYNC_SUSPEND	1
-#define VESA_HSYNC_SUSPEND	2
-#define VESA_POWERDOWN		3
+/* This will go away
+ * fbset currently hacks in FB_ACCELF_TEXT into var.accel_flags
+ * when it wants to turn the acceleration engine on.  This is
+ * really a separate operation, and should be modified via sysfs.
+ *  But for now, we leave it broken with the following define
+ */
+#define STUPID_ACCELF_TEXT_SHIT
 
-#endif /* __KERNEL__ */
+// This will go away
+#if defined(__sparc__)
 
-#if 1
+/* We map all of our framebuffers such that big-endian accesses
+ * are what we want, so the following is sufficient.
+ */
+
+// This will go away
+#define fb_readb sbus_readb
+#define fb_readw sbus_readw
+#define fb_readl sbus_readl
+#define fb_readq sbus_readq
+#define fb_writeb sbus_writeb
+#define fb_writew sbus_writew
+#define fb_writel sbus_writel
+#define fb_writeq sbus_writeq
+#define fb_memset sbus_memset_io
+#define fb_memcpy_fromfb sbus_memcpy_fromio
+#define fb_memcpy_tofb sbus_memcpy_toio
+
+#elif defined(__i386__) || defined(__alpha__) || defined(__x86_64__) || defined(__hppa__) || defined(__sh__) || defined(__powerpc__) || defined(__avr32__) || defined(__bfin__)
+
+#define fb_readb __raw_readb
+#define fb_readw __raw_readw
+#define fb_readl __raw_readl
+#define fb_readq __raw_readq
+#define fb_writeb __raw_writeb
+#define fb_writew __raw_writew
+#define fb_writel __raw_writel
+#define fb_writeq __raw_writeq
+#define fb_memset memset_io
+#define fb_memcpy_fromfb memcpy_fromio
+#define fb_memcpy_tofb memcpy_toio
+
+#else
 
-#define FBCMD_GET_CURRENTPAR	0xDEAD0005
-#define FBCMD_SET_CURRENTPAR	0xDEAD8005
+#define fb_readb(addr) (*(volatile u8 *) (addr))
+#define fb_readw(addr) (*(volatile u16 *) (addr))
+#define fb_readl(addr) (*(volatile u32 *) (addr))
+#define fb_readq(addr) (*(volatile u64 *) (addr))
+#define fb_writeb(b,addr) (*(volatile u8 *) (addr) = (b))
+#define fb_writew(b,addr) (*(volatile u16 *) (addr) = (b))
+#define fb_writel(b,addr) (*(volatile u32 *) (addr) = (b))
+#define fb_writeq(b,addr) (*(volatile u64 *) (addr) = (b))
+#define fb_memset memset
+#define fb_memcpy_fromfb memcpy
+#define fb_memcpy_tofb memcpy
 
 #endif
 
+#define FB_LEFT_POS(p, bpp)          (fb_be_math(p) ? (32 - (bpp)) : 0)
+#define FB_SHIFT_HIGH(p, val, bits)  (fb_be_math(p) ? (val) >> (bits) : \
+						      (val) << (bits))
+#define FB_SHIFT_LOW(p, val, bits)   (fb_be_math(p) ? (val) << (bits) : \
+						      (val) >> (bits))
 
-#if 1 /* Preliminary */
+    /*
+     *  `Generic' versions of the frame buffer device operations
+     */
 
-   /*
-    *    Hardware Cursor
-    */
+extern int fb_set_var(struct fb_info *info, struct fb_var_screeninfo *var); 
+extern int fb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var); 
+extern int fb_blank(struct fb_info *info, int blank);
+extern void cfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect); 
+extern void cfb_copyarea(struct fb_info *info, const struct fb_copyarea *area); 
+extern void cfb_imageblit(struct fb_info *info, const struct fb_image *image);
+/*
+ * Drawing operations where framebuffer is in system RAM
+ */
+extern void sys_fillrect(struct fb_info *info, const struct fb_fillrect *rect);
+extern void sys_copyarea(struct fb_info *info, const struct fb_copyarea *area);
+extern void sys_imageblit(struct fb_info *info, const struct fb_image *image);
+extern ssize_t fb_sys_read(struct fb_info *info, char __user *buf,
+			   size_t count, loff_t *ppos);
+extern ssize_t fb_sys_write(struct fb_info *info, const char __user *buf,
+			    size_t count, loff_t *ppos);
+
+/* drivers/video/fbmem.c */
+extern int register_framebuffer(struct fb_info *fb_info);
+extern int unregister_framebuffer(struct fb_info *fb_info);
+extern void remove_conflicting_framebuffers(struct apertures_struct *a,
+				const char *name, bool primary);
+extern int fb_prepare_logo(struct fb_info *fb_info, int rotate);
+extern int fb_show_logo(struct fb_info *fb_info, int rotate);
+extern char* fb_get_buffer_offset(struct fb_info *info, struct fb_pixmap *buf, u32 size);
+extern void fb_pad_unaligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 idx,
+				u32 height, u32 shift_high, u32 shift_low, u32 mod);
+extern void fb_pad_aligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 s_pitch, u32 height);
+extern void fb_set_suspend(struct fb_info *info, int state);
+extern int fb_get_color_depth(struct fb_var_screeninfo *var,
+			      struct fb_fix_screeninfo *fix);
+extern int fb_get_options(char *name, char **option);
+extern int fb_new_modelist(struct fb_info *info);
+
+extern struct fb_info *registered_fb[FB_MAX];
+extern int num_registered_fb;
+extern struct class *fb_class;
+
+extern int lock_fb_info(struct fb_info *info);
+
+static inline void unlock_fb_info(struct fb_info *info)
+{
+	mutex_unlock(&info->lock);
+}
+
+static inline void __fb_pad_aligned_buffer(u8 *dst, u32 d_pitch,
+					   u8 *src, u32 s_pitch, u32 height)
+{
+	int i, j;
+
+	d_pitch -= s_pitch;
+
+	for (i = height; i--; ) {
+		/* s_pitch is a few bytes at the most, memcpy is suboptimal */
+		for (j = 0; j < s_pitch; j++)
+			*dst++ = *src++;
+		dst += d_pitch;
+	}
+}
+
+/* drivers/video/fb_defio.c */
+extern void fb_deferred_io_init(struct fb_info *info);
+extern void fb_deferred_io_open(struct fb_info *info,
+				struct inode *inode,
+				struct file *file);
+extern void fb_deferred_io_cleanup(struct fb_info *info);
+extern int fb_deferred_io_fsync(struct file *file, int datasync);
+
+static inline bool fb_be_math(struct fb_info *info)
+{
+#ifdef CONFIG_FB_FOREIGN_ENDIAN
+#if defined(CONFIG_FB_BOTH_ENDIAN)
+	return info->flags & FBINFO_BE_MATH;
+#elif defined(CONFIG_FB_BIG_ENDIAN)
+	return true;
+#elif defined(CONFIG_FB_LITTLE_ENDIAN)
+	return false;
+#endif /* CONFIG_FB_BOTH_ENDIAN */
+#else
+#ifdef __BIG_ENDIAN
+	return true;
+#else
+	return false;
+#endif /* __BIG_ENDIAN */
+#endif /* CONFIG_FB_FOREIGN_ENDIAN */
+}
+
+/* drivers/video/fbsysfs.c */
+extern struct fb_info *framebuffer_alloc(size_t size, struct device *dev);
+extern void framebuffer_release(struct fb_info *info);
+extern int fb_init_device(struct fb_info *fb_info);
+extern void fb_cleanup_device(struct fb_info *head);
+extern void fb_bl_default_curve(struct fb_info *fb_info, u8 off, u8 min, u8 max);
+
+/* drivers/video/fbmon.c */
+#define FB_MAXTIMINGS		0
+#define FB_VSYNCTIMINGS		1
+#define FB_HSYNCTIMINGS		2
+#define FB_DCLKTIMINGS		3
+#define FB_IGNOREMON		0x100
+
+#define FB_MODE_IS_UNKNOWN	0
+#define FB_MODE_IS_DETAILED	1
+#define FB_MODE_IS_STANDARD	2
+#define FB_MODE_IS_VESA		4
+#define FB_MODE_IS_CALCULATED	8
+#define FB_MODE_IS_FIRST	16
+#define FB_MODE_IS_FROM_VAR     32
 
-#define FBIOGET_FCURSORINFO     0x4607
-#define FBIOGET_VCURSORINFO     0x4608
-#define FBIOPUT_VCURSORINFO     0x4609
-#define FBIOGET_CURSORSTATE     0x460A
-#define FBIOPUT_CURSORSTATE     0x460B
+extern int fbmon_dpms(const struct fb_info *fb_info);
+extern int fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var,
+		       struct fb_info *info);
+extern int fb_validate_mode(const struct fb_var_screeninfo *var,
+			    struct fb_info *info);
+extern int fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var);
+extern const unsigned char *fb_firmware_edid(struct device *device);
+extern void fb_edid_to_monspecs(unsigned char *edid,
+				struct fb_monspecs *specs);
+extern void fb_edid_add_monspecs(unsigned char *edid,
+				 struct fb_monspecs *specs);
+extern void fb_destroy_modedb(struct fb_videomode *modedb);
+extern int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb);
+extern unsigned char *fb_ddc_read(struct i2c_adapter *adapter);
+
+/* drivers/video/modedb.c */
+#define VESA_MODEDB_SIZE 34
+extern void fb_var_to_videomode(struct fb_videomode *mode,
+				const struct fb_var_screeninfo *var);
+extern void fb_videomode_to_var(struct fb_var_screeninfo *var,
+				const struct fb_videomode *mode);
+extern int fb_mode_is_equal(const struct fb_videomode *mode1,
+			    const struct fb_videomode *mode2);
+extern int fb_add_videomode(const struct fb_videomode *mode,
+			    struct list_head *head);
+extern void fb_delete_videomode(const struct fb_videomode *mode,
+				struct list_head *head);
+extern const struct fb_videomode *fb_match_mode(const struct fb_var_screeninfo *var,
+						struct list_head *head);
+extern const struct fb_videomode *fb_find_best_mode(const struct fb_var_screeninfo *var,
+						    struct list_head *head);
+extern const struct fb_videomode *fb_find_nearest_mode(const struct fb_videomode *mode,
+						       struct list_head *head);
+extern void fb_destroy_modelist(struct list_head *head);
+extern void fb_videomode_to_modelist(const struct fb_videomode *modedb, int num,
+				     struct list_head *head);
+extern const struct fb_videomode *fb_find_best_display(const struct fb_monspecs *specs,
+						       struct list_head *head);
 
+/* drivers/video/fbcmap.c */
+extern int fb_alloc_cmap(struct fb_cmap *cmap, int len, int transp);
+extern int fb_alloc_cmap_gfp(struct fb_cmap *cmap, int len, int transp, gfp_t flags);
+extern void fb_dealloc_cmap(struct fb_cmap *cmap);
+extern int fb_copy_cmap(const struct fb_cmap *from, struct fb_cmap *to);
+extern int fb_cmap_to_user(const struct fb_cmap *from, struct fb_cmap_user *to);
+extern int fb_set_cmap(struct fb_cmap *cmap, struct fb_info *fb_info);
+extern int fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *fb_info);
+extern const struct fb_cmap *fb_default_cmap(int len);
+extern void fb_invert_cmaps(void);
 
-struct fb_fix_cursorinfo {
-	__u16 crsr_width;		/* width and height of the cursor in */
-	__u16 crsr_height;		/* pixels (zero if no cursor)	*/
-	__u16 crsr_xsize;		/* cursor size in display pixels */
-	__u16 crsr_ysize;
-	__u16 crsr_color1;		/* colormap entry for cursor color1 */
-	__u16 crsr_color2;		/* colormap entry for cursor color2 */
+struct fb_videomode {
+	const char *name;	/* optional */
+	u32 refresh;		/* optional */
+	u32 xres;
+	u32 yres;
+	u32 pixclock;
+	u32 left_margin;
+	u32 right_margin;
+	u32 upper_margin;
+	u32 lower_margin;
+	u32 hsync_len;
+	u32 vsync_len;
+	u32 sync;
+	u32 vmode;
+	u32 flag;
 };
 
-struct fb_var_cursorinfo {
-	__u16 width;
-	__u16 height;
-	__u16 xspot;
-	__u16 yspot;
-	__u8 data[1];			/* field with [height][width]        */
-};
+extern const char *fb_mode_option;
+extern const struct fb_videomode vesa_modes[];
+extern const struct fb_videomode cea_modes[64];
 
-struct fb_cursorstate {
-	__s16 xoffset;
-	__s16 yoffset;
-	__u16 mode;
+struct fb_modelist {
+	struct list_head list;
+	struct fb_videomode mode;
 };
 
-#define FB_CURSOR_OFF		0
-#define FB_CURSOR_ON		1
-#define FB_CURSOR_FLASH		2
+extern int fb_find_mode(struct fb_var_screeninfo *var,
+			struct fb_info *info, const char *mode_option,
+			const struct fb_videomode *db,
+			unsigned int dbsize,
+			const struct fb_videomode *default_mode,
+			unsigned int default_bpp);
 
-#endif /* Preliminary */
+#endif /* __KERNEL__ */
 
 #endif /* _LINUX_FB_H */
diff --git a/fb.modes.5 b/fb.modes.5
index 0918f08..106d4c7 100644
--- a/fb.modes.5
+++ b/fb.modes.5
@@ -1,4 +1,4 @@
-.TH fb.modes 8 "Aug 1996" local "Linux frame buffer utils"
+.TH fb.modes 5 2003-08-07 2.1 "Linux frame buffer utils"
 .SH NAME
 fb.modes \- frame buffer modes file
 .SH DESCRIPTION
@@ -27,6 +27,9 @@ timings
 .br
 .B options
 .RI < value >
+.br
+.B rgba
+.RI < red , green , blue , alpha >
 .RE
 endmode
 .SH OPTIONS
@@ -74,6 +77,22 @@ horizontal sync length (in pixels)
 vertical sync length (in pixel lines)
 .RE
 .PP
+rgba options (only valid with truecolor):
+.RS
+.TP
+.I red
+red color bitfields (in length or length/offset)
+.TP
+.I green
+green color bitfields (in length or length/offset)
+.TP
+.I blue
+blue color bitfields (in length or length/offset)
+.TP
+.I alpha
+alpha color bitfields (in length or length/offset)
+.RE
+.PP
 other options:
 .RS
 the first value of this options is the default
@@ -87,12 +106,23 @@ the vertical sync polarity
 .IR \fBcsync "\ {" low | high }
 the composite sync polarity
 .TP
+.IR \fBgsync "\ {" low | high }
+the sync on green polarity
+.TP
+.IR \fBbcast "\ {" false | true }
+enable or disable broadcast modes. If enabled the frame buffer generates
+the exact timings fot several broadcast modes (e.g. PAL or NTSC). Note that
+this option may not be supported by every frame buffer
+.TP
 .IR \fBextsync "\ {" false | true }
 enable or disable external resync. If enabled the sync timings are not
 generated by the frame buffer device and must be provided externally
 instead. Note that this option may not be supported by every frame buffer
 device
 .TP
+.IR \fBsync "\ <" number >
+custom sync flags (frame buffer driver dependent)
+.TP
 .IR \fBlaced "\ {" false | true }
 enable or disable interlace. If enabled the display will be split in two
 frames, each frame contains only even and odd lines respectively. These two
@@ -106,6 +136,15 @@ and this way the horizontal frequency can easily be doubled, so that the
 same resolution can be displayed on different monitors, even if the
 horizontal frequency specification differs. Note that this option may not be
 supported by every frame buffer device
+.TP
+.IR \fBnostd "\ <" number >
+select nonstandard video mode
+.TP
+.IR \fBaccel "\ {" false | true }
+enable or disable hardware text acceleration
+.TP
+.IR \fBgrayscale "\ {" false | true }
+enable or disable graylevels instead of colors
 .RE
 .SH INTERNALS
 Generally a frame buffer display is organized as follows:
diff --git a/fbset.8 b/fbset.8
index 74e7d3c..587553e 100644
--- a/fbset.8
+++ b/fbset.8
@@ -1,4 +1,4 @@
-.TH fbset 8 "July 1998" local "Linux frame buffer utils"
+.TH fbset 1 2010-04-12 2.1 "Linux frame buffer utils"
 .SH NAME
 fbset \- show and modify frame buffer device settings
 .SH SYNOPSIS
@@ -6,8 +6,6 @@ fbset \- show and modify frame buffer device settings
 .RI [ options ]
 .RI [ mode ]
 .SH DESCRIPTION
-.B This documentation is out of date!!
-.PP
 .B fbset
 is a system utility to show or change the settings of the frame buffer
 device. The frame buffer device provides a simple and unique interface to
@@ -36,10 +34,8 @@ General options:
 .BR \-\-help ",\ " \-h
 display an usage information
 .TP
-.BR \-\-now ",\ " \-n
-change the video mode immediately. If no frame buffer device is given via
-.B \-fb
-, then this option is activated by default
+.BR \-\-test
+don't change, just test whether the mode is valid
 .TP
 .BR \-\-show ",\ " \-s
 display the video mode settings. This is default if no further option or
@@ -66,6 +62,9 @@ display the timing information as it's needed by XFree86
 Frame buffer device nodes:
 .RS
 .TP
+.BR \-\-all ",\ "  \-a
+change all virtual consoles on this device
+.TP
 .BR \-fb "\ <" \fIdevice >
 .I device
 gives the frame buffer device node. If no device via
@@ -73,7 +72,6 @@ gives the frame buffer device node. If no device via
 is given, 
 .I /dev/fb0
 is used
-.TP
 .RE
 .PP
 Video mode database:
@@ -86,6 +84,13 @@ see also
 .BR fb.modes (5)
 .RE
 .PP
+Display bitfield colors:
+.RS
+.TP
+.BR \-rgba "\ <" \fIred , \fIgreen , \fIblue , \fIalpha >
+each in length or length/offset color format
+.RE
+.PP
 Display geometry:
 .RS
 .TP
@@ -104,6 +109,10 @@ set virtual vertical resolution (in pixels)
 .BR \-depth "\ <" \fIvalue >
 set display depth (in bits per pixel)
 .TP
+.TP
+.BR \-nonstd "\ <" \fIvalue >
+select nonstandard video mode
+.TP
 .BR \-\-geometry ",\ " \-g "\ ..."
 set all geometry parameters at once in the order
 .RI < xres >
@@ -154,13 +163,16 @@ set all timing parameters at once in the order
 .RI < hslen >
 .RI < vslen >,
 e.g.
-.B \-g
+.B \-t
 .I 35242 64 96 35 12 112 2
 .RE
 .PP
 Display flags:
 .RS
 .TP
+.IR \fB\-accel "\ {" false | true }
+set hardware text acceleration enable
+.TP
 .IR \fB\-hsync "\ {" low | high }
 set the horizontal sync polarity
 .TP
@@ -170,12 +182,19 @@ set the vertical sync polarity
 .IR \fB\-csync "\ {" low | high }
 set the composite sync polarity
 .TP
+.IR \fB\-gsync "\ {" false | true }
+set synch on green
+.TP
 .IR \fB\-extsync "\ {" false | true }
 enable or disable external resync. If enabled the sync timings are not
 generated by the frame buffer device and must be provided externally
 instead. Note that this option may not be supported by every frame buffer
 device
 .TP
+.IR \fB\-sync "\ <" \fIvalue >
+set custom sync flags. If specified, this value is bitwise or-ed to the
+other sync flags. This is useful for drivers that use custom sync flags
+.TP
 .IR \fB\-bcast "\ {" false | true }
 enable or disable broadcast modes. If enabled the frame buffer generates the
 exact timings for several broadcast modes (e.g. PAL or NTSC). Note that
@@ -217,7 +236,7 @@ insert the following in rc.local:
 .B fbset
 -fb
 .I /dev/fb0
-vga
+640x480\-60
 .sp
 .RE
 and make the used frame buffer device known to
@@ -232,7 +251,7 @@ and make the used frame buffer device known to
 .br
 .I /etc/fb.modes
 .SH SEE ALSO
-.BR fb.modes "(5), " fbdev (4)
+.BR fb.modes "(5), " fbdev "(4), " /usr/share/doc/fbset/FAQ.gz
 .SH AUTHORS
 .TP
 Geert Uytterhoeven <Geert.Uytterhoeven@cs.kuleuven.ac.be>
diff --git a/fbset.c b/fbset.c
index a9da078..1e84618 100644
--- a/fbset.c
+++ b/fbset.c
@@ -16,6 +16,9 @@
  *  Brad Midgley <brad@exodus.pht.com>:
  *           -match
  *
+ *  David Kozub <zub@linux.fjfi.cvut.cz>:
+ *           -sync
+ *
  */
 
 
@@ -52,6 +55,12 @@ struct inode;
 
 
     /*
+     *  Mask to zero-out all known sync flags
+     */
+#define FB_CUSTOM_SYNC_MASK ~(FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT| \
+    FB_SYNC_COMP_HIGH_ACT|FB_SYNC_ON_GREEN|FB_SYNC_EXT|FB_SYNC_BROADCAST)
+
+    /*
      *  Command Line Options
      */
 
@@ -86,6 +95,7 @@ static const char *Opt_vsync = NULL;
 static const char *Opt_csync = NULL;
 static const char *Opt_gsync = NULL;
 static const char *Opt_extsync = NULL;
+static const char *Opt_sync = NULL;
 static const char *Opt_bcast = NULL;
 static const char *Opt_laced = NULL;
 static const char *Opt_double = NULL;
@@ -123,6 +133,7 @@ static struct {
     { "-csync", &Opt_csync, 1 },
     { "-gsync", &Opt_gsync, 1 },
     { "-extsync", &Opt_extsync, 1 },
+    { "-sync", &Opt_sync, 1 },
     { "-bcast", &Opt_bcast, 1 },
     { "-laced", &Opt_laced, 1 },
     { "-double", &Opt_double, 1 },
@@ -199,6 +210,60 @@ static struct accelentry {
     { FB_ACCEL_SUN_CGTHREE, "Sun cg3" },
     { FB_ACCEL_SUN_TCX, "Sun tcx" },
     { FB_ACCEL_MATROX_MGAG400, "Matrox G400" },
+    { FB_ACCEL_NV3, "nVidia RIVA 128" },
+    { FB_ACCEL_NV4, "nVidia RIVA TNT" },
+    { FB_ACCEL_NV5, "nVidia RIVA TNT2" },
+    { FB_ACCEL_CT_6555x, "C&T 6555x" },
+    { FB_ACCEL_3DFX_BANSHEE, "3Dfx Banshee" },
+    { FB_ACCEL_ATI_RAGE128, "ATI Rage128 family" },
+    { FB_ACCEL_ATI_RADEON, "ATI Radeon family" },
+    { FB_ACCEL_IGS_CYBER2000, "CyberPro 2000" },
+    { FB_ACCEL_IGS_CYBER2010, "CyberPro 2010" },
+    { FB_ACCEL_IGS_CYBER5000, "CyberPro 5000" },
+    { FB_ACCEL_SIS_GLAMOUR, "SiS 300/630/540" },
+    { FB_ACCEL_SIS_GLAMOUR_2, "SiS 315/650/740" },
+    { FB_ACCEL_SIS_XABRE, "SiS 330 (Xabre)" },
+    { FB_ACCEL_3DLABS_PERMEDIA3, "3Dlabs Permedia 3" },
+    { FB_ACCEL_I810, "Intel 810/815" },
+    { FB_ACCEL_I830, "Intel 830M/845G/85x/865G" },
+    { FB_ACCEL_NEOMAGIC_NM2070, "NeoMagic NM2070" },
+    { FB_ACCEL_NEOMAGIC_NM2090, "NeoMagic NM2090" },
+    { FB_ACCEL_NEOMAGIC_NM2093, "NeoMagic NM2093" },
+    { FB_ACCEL_NEOMAGIC_NM2097, "NeoMagic NM2097" },
+    { FB_ACCEL_NEOMAGIC_NM2160, "NeoMagic NM2160" },
+    { FB_ACCEL_NEOMAGIC_NM2200, "NeoMagic NM2200" },
+    { FB_ACCEL_NEOMAGIC_NM2230, "NeoMagic NM2230" },
+    { FB_ACCEL_NEOMAGIC_NM2360, "NeoMagic NM2360" },
+    { FB_ACCEL_NEOMAGIC_NM2380, "NeoMagic NM2380" },
+    { FB_ACCEL_PXA3XX, "PXA3xx" },
+    { FB_ACCEL_SAVAGE4, "S3 Savage4" },
+    { FB_ACCEL_SAVAGE3D, "S3 Savage3D" },
+    { FB_ACCEL_SAVAGE3D_MV, "S3 Savage3D-MV" },
+    { FB_ACCEL_SAVAGE2000, "S3 Savage2000" },
+    { FB_ACCEL_SAVAGE_MX_MV, "S3 Savage/MX-MV" },
+    { FB_ACCEL_SAVAGE_MX, "S3 Savage/MX" },
+    { FB_ACCEL_SAVAGE_IX_MV, "S3 Savage/IX-MV" },
+    { FB_ACCEL_SAVAGE_IX, "S3 Savage/IX" },
+    { FB_ACCEL_PROSAVAGE_PM, "S3 ProSavage PM133" },
+    { FB_ACCEL_PROSAVAGE_KM, "S3 ProSavage KM133" },
+    { FB_ACCEL_S3TWISTER_P, "S3 Twister" },
+    { FB_ACCEL_S3TWISTER_K, "S3 TwisterK" },
+    { FB_ACCEL_SUPERSAVAGE, "S3 Supersavage" },
+    { FB_ACCEL_PROSAVAGE_DDR, "S3 ProSavage DDR" },
+    { FB_ACCEL_PROSAVAGE_DDRK, "S3 ProSavage DDR-K" },
+    { FB_ACCEL_PUV3_UNIGFX, "PKUnity-v3 Unigfx" },
+    { FB_ACCEL_NV_10, "nVidia Arch 10" },
+    { FB_ACCEL_NV_20, "nVidia Arch 20" },
+    { FB_ACCEL_NV_30, "nVidia Arch 30" },
+    { FB_ACCEL_NV_40, "nVidia Arch 40" },
+    { FB_ACCEL_XGI_VOLARI_V, "XGI Volari V3XT, V5, V8" },
+    { FB_ACCEL_XGI_VOLARI_Z, "XGI Volari Z7" },
+    { FB_ACCEL_OMAP1610, "TI OMAP16xx" },
+    { FB_ACCEL_TRIDENT_TGUI, "Trident TGUI" },
+    { FB_ACCEL_TRIDENT_3DIMAGE, "Trident 3DImage" },
+    { FB_ACCEL_TRIDENT_BLADE3D, "Trident Blade3D" },
+    { FB_ACCEL_TRIDENT_BLADEXP, "Trident BladeXP" },
+    { FB_ACCEL_CIRRUS_ALPINE, "Cirrus Logic 543x/544x/5480" },
 };
 
 
@@ -348,6 +413,7 @@ static void ConvertFromVideoMode(const struct VideoMode *vmode,
 	var->sync |= FB_SYNC_EXT;
     if (vmode->bcast == TRUE)
 	var->sync |= FB_SYNC_BROADCAST;
+    var->sync |= vmode->sync;
     if (vmode->laced == TRUE)
 	var->vmode = FB_VMODE_INTERLACED;
     else if (vmode->dblscan == TRUE)
@@ -391,6 +457,7 @@ static void ConvertToVideoMode(const struct fb_var_screeninfo *var,
     vmode->gsync = var->sync & FB_SYNC_ON_GREEN ? TRUE : FALSE;
     vmode->extsync = var->sync & FB_SYNC_EXT ? TRUE : FALSE;
     vmode->bcast = var->sync & FB_SYNC_BROADCAST ? TRUE : FALSE;
+    vmode->sync = var->sync & FB_CUSTOM_SYNC_MASK;
     vmode->grayscale = var->grayscale;
     vmode->laced = FALSE;
     vmode->dblscan = FALSE;
@@ -500,6 +567,27 @@ void makeRGBA(struct VideoMode *vmode, const char* opt)
 }
 
     /*
+     *  Take known bits from sync and set appropriate flags instead
+     */
+
+void fixCustomSync(struct VideoMode *vmode)
+{
+    if (vmode->sync & FB_SYNC_HOR_HIGH_ACT)
+	vmode->hsync = 1;
+    if (vmode->sync & FB_SYNC_VERT_HIGH_ACT)
+	vmode->vsync = 1;
+    if (vmode->sync & FB_SYNC_COMP_HIGH_ACT)
+	vmode->csync = 1;
+    if (vmode->sync & FB_SYNC_ON_GREEN)
+	vmode->gsync = 1;
+    if (vmode->sync & FB_SYNC_EXT)
+	vmode->extsync =1;
+    if (vmode->sync & FB_SYNC_BROADCAST)
+	vmode->bcast = 1;
+    vmode->sync &= FB_CUSTOM_SYNC_MASK;
+}
+
+    /*
      *  Find a Video Mode
      */
 
@@ -563,6 +651,12 @@ static void ModifyVideoMode(struct VideoMode *vmode)
 	vmode->extsync = atoboolean(Opt_extsync);
     if (Opt_bcast)
 	vmode->bcast = atoboolean(Opt_bcast);
+    if (Opt_sync)
+    {
+	vmode->sync = strtoul(Opt_sync, NULL, 0);
+	// call this only once all the other sync fields are determined!
+	fixCustomSync(vmode);
+    }
     if (Opt_laced)
 	vmode->laced = atoboolean(Opt_laced);
     if (Opt_double)
@@ -639,6 +733,8 @@ static void DisplayVModeInfo(struct VideoMode *vmode)
 	    puts("    extsync true");
 	if (vmode->bcast)
 	    puts("    bcast true");
+	if (vmode->sync)
+	    printf("    sync 0x%x\n", vmode->sync);
 	if (vmode->laced)
 	    puts("    laced true");
 	if (vmode->dblscan)
@@ -691,6 +787,8 @@ static void DisplayVModeInfo(struct VideoMode *vmode)
 	    puts("    # Warning: XFree86 doesn't support extsync\n");
 	if (vmode->bcast)
 	    printf(" \"bcast\"");
+	if (vmode->sync)
+	    puts("    # Warning: XFree86 doesn't support custom sync values\n");
 	if (vmode->accel_flags)
 	    puts("    # Warning: XFree86 doesn't support accel\n");
 	if (vmode->grayscale)
@@ -710,7 +808,7 @@ static void DisplayFBInfo(struct fb_fix_screeninfo *fix)
 
     puts("Frame buffer device information:");
     printf("    Name        : %s\n", fix->id);
-    printf("    Address     : %p\n", fix->smem_start);
+    printf("    Address     : %#0lx\n", fix->smem_start);
     printf("    Size        : %d\n", fix->smem_len);
     printf("    Type        : ");
     switch (fix->type) {
@@ -780,7 +878,7 @@ static void DisplayFBInfo(struct fb_fix_screeninfo *fix)
     printf("    YWrapStep   : %d\n", fix->ywrapstep);
     printf("    LineLength  : %d\n", fix->line_length);
     if (fix->mmio_len) {
-	printf("    MMIO Address: %p\n", fix->mmio_start);
+	printf("    MMIO Address: %#0lx\n", fix->mmio_start);
 	printf("    MMIO Size   : %d\n", fix->mmio_len);
     }
     printf("    Accelerator : ");
@@ -832,7 +930,8 @@ static int FillScanRates(struct VideoMode *vmode)
 static void Usage(void)
 {
     puts(VERSION);
-    Die("\nUsage: %s [options] [mode]\n\n"
+    printf(
+	"\nUsage: %s [options] [mode]\n\n"
 	"Valid options:\n"
 	"  General options:\n"
 	"    -h, --help         : display this usage information\n"
@@ -876,6 +975,7 @@ static void Usage(void)
 	"    -csync <value>     : composite sync polarity (low or high)\n"
 	"    -gsync <value>     : synch on green (false or true)\n"
 	"    -extsync <value>   : external sync enable (false or true)\n"
+	"    -sync <value>      : custom (driver specific) sync value\n"
 	"    -bcast <value>     : broadcast enable (false or true)\n"
 	"    -laced <value>     : interlace enable (false or true)\n"
 	"    -double <value>    : doublescan enable (false or true)\n"
@@ -887,6 +987,7 @@ static void Usage(void)
 	"    -step <value>      : step increment (in pixels or pixel lines)\n"
 	"                         (default is 8 horizontal, 2 vertical)\n",
 	ProgramName);
+	exit(0);
 }
 
 
diff --git a/fbset.h b/fbset.h
index 9b1d2ac..fafe385 100644
--- a/fbset.h
+++ b/fbset.h
@@ -38,22 +38,22 @@ struct VideoMode {
     struct VideoMode *next;
     const char *name;
     /* geometry */
-    __u32 xres;
-    __u32 yres;
-    __u32 vxres;
-    __u32 vyres;
-    __u32 depth;
-    __u32 nonstd;
+    uint32_t xres;
+    uint32_t yres;
+    uint32_t vxres;
+    uint32_t vyres;
+    uint32_t depth;
+    uint32_t nonstd;
     /* acceleration */
-    __u32 accel_flags;
+    uint32_t accel_flags;
     /* timings */
-    __u32 pixclock;
-    __u32 left;
-    __u32 right;
-    __u32 upper;
-    __u32 lower;
-    __u32 hslen;
-    __u32 vslen;
+    uint32_t pixclock;
+    uint32_t left;
+    uint32_t right;
+    uint32_t upper;
+    uint32_t lower;
+    uint32_t hslen;
+    uint32_t vslen;
     /* flags */
     unsigned hsync : 1;
     unsigned vsync : 1;
@@ -64,6 +64,8 @@ struct VideoMode {
     unsigned laced : 1;
     unsigned dblscan : 1;
     unsigned grayscale : 1;
+    /* extra (fb driver specific) sync bits */
+    uint32_t sync;
     /* scanrates */
     double drate;
     double hrate;
@@ -80,3 +82,4 @@ extern int yyparse(void);
 extern void Die(const char *fmt, ...) __attribute__ ((noreturn));
 extern void AddVideoMode(const struct VideoMode *vmode);
 extern void makeRGBA(struct VideoMode *vmode, const char* opt);
+extern void fixCustomSync(struct VideoMode *vmode);
diff --git a/modeline2fb.1 b/modeline2fb.1
new file mode 100644
index 0000000..5fccf69
--- /dev/null
+++ b/modeline2fb.1
@@ -0,0 +1,40 @@
+.TH modeline2fb 1 2006-01-18 2.1 "Linux frame buffer utils"
+.SH NAME
+modeline2fb \- simple modeline to fb.modes translator
+.SH SYNOPSIS
+.B modeline2fb
+[\fIOPTION\fR] [\fIFILES\fR]
+.SH DESCRIPTION
+.PP
+.I Modeline2fb
+is a simple Perl script that converts XF86Config-style modelines to options
+suitable for a fb.modes file.
+.PP
+Note that only one option can be successfully enabled at any particular time.
+.SH OPTIONS
+.TP
+\fB\-d\fR, \fB\-\-depth\fR \fIdepth\fR
+Use the given display depth (default is 8).
+.TP
+\fB\-h\fR \fB\-\-help\fR
+Print out a help screen and exit.
+.SH ADVANCED OPTIONS
+.TP
+\fB\-r\fR \fB\-\-rounding\fR \fIdiv\fR
+Sets the vxres divisor (default is 128).
+.TP
+\fB\-x\fR \fB\-\-vxres\fR \fIX,X,X,...\fR
+Sets extra vxres values.
+.PP
+[\fIFILES\fR] refers to one or more XF86Config files.  Note that all modelines 
+must be in single-line format.  If no files are given on the command line, 
+this program reads from standard in.  This program will also write to
+standard out.
+.SH EXAMPLE 
+modeline2fb \-d 16 /etc/X11/XF86Config
+.SH "SEE ALSO"
+.BR fb.modes(5), 
+.BR XF86Config(5)
+.SH AUTHOR
+This manual page is a quick write-up for Debian done by Kevin Kreamer 
+<kkreamer@etherhogz.org>.
diff --git a/modes.l b/modes.l
index 426eb5c..c4af1c3 100644
--- a/modes.l
+++ b/modes.l
@@ -38,6 +38,7 @@ static struct keyword keywords[] = {
     { "csync", CSYNC, 0 },
     { "gsync", GSYNC, 0 },
     { "extsync", EXTSYNC, 0 },
+    { "sync", SYNC, 0 },
     { "bcast", BCAST, 0 },
     { "laced", LACED, 0 },
     { "double", DOUBLE, 0 },
@@ -98,7 +99,8 @@ static const char *CopyString(const char *s)
 %}
 
 keyword	[a-zA-Z][a-zA-Z0-9]*
-number	[0-9]*
+number	(0x)?[0-9]*
+colors	[0-9/,]*
 string	\"[^\"\n]*\"
 comment	\#([^\n]*)
 space	[ \t]+
@@ -115,6 +117,11 @@ junk	.
 		return NUMBER;
 	    }
 
+{colors}    {
+		yylval = (unsigned long)CopyString(yytext);
+		return COLORS;
+	    }
+
 {string}    {
 		yylval = (unsigned long)CopyString(yytext);
 		return STRING;
diff --git a/modes.y b/modes.y
index 27b497a..bf1a6b5 100644
--- a/modes.y
+++ b/modes.y
@@ -40,9 +40,9 @@ static void ClearVideoMode(void)
 
 %start file
 
-%token MODE GEOMETRY TIMINGS HSYNC VSYNC CSYNC GSYNC EXTSYNC BCAST LACED DOUBLE
+%token MODE GEOMETRY TIMINGS HSYNC VSYNC CSYNC GSYNC EXTSYNC SYNC BCAST LACED DOUBLE
        RGBA NONSTD ACCEL GRAYSCALE
-       ENDMODE POLARITY BOOLEAN STRING NUMBER 
+       ENDMODE POLARITY BOOLEAN STRING NUMBER COLORS
 
 %%
 
@@ -91,6 +91,7 @@ options	  : /* empty */
 	  | options csync
 	  | options gsync
 	  | options extsync
+	  | options sync
 	  | options bcast
 	  | options laced
 	  | options double
@@ -130,6 +131,13 @@ extsync	  : EXTSYNC BOOLEAN
 	    }
 	  ;
 
+sync: SYNC NUMBER
+	    {
+		VideoMode.sync = $2;
+		fixCustomSync(&VideoMode);
+	    }
+	  ;
+
 bcast	  : BCAST BOOLEAN
 	    {
 		VideoMode.bcast = $2;
@@ -148,7 +156,7 @@ double	  : DOUBLE BOOLEAN
 	    }
 	  ;
 
-rgba      : RGBA STRING
+rgba      : RGBA COLORS
             {
 		makeRGBA(&VideoMode, (const char*)$2);
 	    }
